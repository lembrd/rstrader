# OMS Order Management System and Order Routing


## MonotonicallyIncreaseGenerator
Based on the Twitter Snowflake algorithm.

Service for generating unique ID numbers at high scale with simple guarantees. The ID is composed of:
- time: 41 bits (millisecond precision with a custom epoch; ~69 years)
- machine ID: 10 bits (up to 1024 machines)
- sequence number: 12 bits (rolls over every 4096 per machine, with safeguards to avoid rollover in the same millisecond)

## Notes about ClOrdId

Most exchanges accept a string field `clOrdId`. We will use a prefixed `xcl_{int64}` format for our system. Inside the system we will use an `int64` `cl_ord_id`. If the exchange-provided string does not have the `xcl` prefix, we will set `cl_ord_id` to `-1`.

It must be a globally unique, monotonically increasing ID; we will use `MonotonicallyIncreaseGenerator` for this.



## Domain model and base entities

### ExecutionType enum
```
    X_UNKNOWN = 0;

    X_TRADE = 10; # fill
    
    X_ORDER_NEW = 20;
    X_ORDER_CANCELED = 30;
    X_ORDER_REPLACED = 40;
    
    
    X_ORDER_PENDING_NEW = 100;
    X_ORDER_PENDING_CANCEL = 110;
    X_ORDER_PENDING_REPLACE = 120;
    
    X_ORDER_REJECTED = 400;

    X_ORDER_TRIGGERED = 600; # for stop orders

    X_FUNDING = 710; # funding transaction
    X_LIQUIDATION = 720; # position liquidation


```
This enum should also provide a method: `is_position_change(): bool` returning true if the execution report changes the current position (`X_TRADE`, `X_LIQUIDATION`).

### OrderStatus enum

```
    O_STATUS_UNKNOWN = 0;

    O_STATUS_NEW = 10;
    O_STATUS_PARTIALLY_FILLED = 20;
    O_STATUS_REPLACED = 30;


    O_STATUS_PENDING_NEW = 110;
    O_STATUS_PENDING_CANCEL = 120;
    O_STATUS_PENDING_REPLACE = 130;

    O_STATUS_FILLED = 230;
    O_STATUS_CANCELED = 240;
    O_STATUS_REJECTED = 250;

```
This enum should also provide a method: `is_alive(): bool` returning true if the order is active (replaced, new, partially filled).

### TimeInForce enum
```

    TIF_UNKNOWN = 0;
    TIF_DAY = 10;
    TIF_GOOD_TILL_CANCEL = 20;    
    TIF_IMMEDIATE_OR_CANCEL = 30;
    TIF_FILL_OR_KILL = 40;

```


### OrderMode enum

```
    M_UNKNOWN = 0;
    M_MARKET = 10;
    M_LIMIT = 20;
    M_STOP_MARKET = 2;
    M_TRAILING_LIMIT = 3;
    M_STOP_LIMIT = 4;
    M_MARKET_IF_TOUCHED = 5;
    M_LIMIT_IF_TOUCHED = 6;
    M_MARKET_WITH_LEFT_OVER_AS_LIMIT = 7;
    M_PEGGED = 8;

```

### XMarketId 
Union of exchange + symbol mapped to a unique `int64` value for performance and speed.
We will maintain a global registry to keep mappings.

### XExecution
```
    int64 timestamp; # exchange timestamp (microseconds UTC)
    int64 rcv_timestamp; # local timestamp when the message was received (microseconds UTC)

    XMarketId market_id; # XMarketId mapping (int64)

    int64 account_id; # exchange account ID mapping

    ExecutionType exec_type; # enum

    Side side; # enum -1 = sell, 1 = buy, 0 = unknown or no side
    
    string native_ord_id; # exchange native order ID

    int64 cl_ord_id; # client order ID, values: -1 = no clOrdId, otherwise our client order ID

    int64 orig_cl_ord_id; # client order ID in case of chained replace (exchange-specific), -1 = no orig_cl_ord_id

    OrderStatus ord_status; # enum

    double last_qty; # last executed quantity

    double last_px; # last executed price

    double leaves_qty; # remaining quantity on the order

    double ord_qty; # order quantity

    double ord_price; # order price

    OrderMode ord_mode; # enum 

    TimeInForce tif; # time-in-force enum

    double fee; # fee amount reported by the exchange; if positive it's a fee, if negative it's a rebate
    
    string native_execution_id; # exchange native ID for the execution

    map<str, str> metadata; # optional metadata included in the request
    
    bool is_taker; # flag indicating it aggressively took liquidity (order-initiated match)
```

### PostRequest
```
    int64 req_id; # unique request ID generated by MonotonicallyIncreaseGenerator
    int64 timestamp; # local timestamp when the request was created (microseconds UTC)
    
    int64 cl_ord_id;

    XMarketId market_id;
    int64 account_id;
    
    Side side;
    double qty; # must be > 0
    double price; # can be 0 for market orders
    OrderMode ord_mode; # default: limit
    TimeInForce tif; # default: Good-Till-Cancelled (GTC)
    bool post_only; # default: true
    bool reduce_only; # default: false
    map<str, str> metadata; # default: none
```

### CancelRequest

One of the two fields (`cl_ord_id`, `native_ord_id`) must be provided.

```
    int64 req_id; # unique request ID generated by MonotonicallyIncreaseGenerator
    int64 timestamp; # local timestamp when the request was created (microseconds UTC)

    XMarketId market_id;
    int64 account_id;

    int64 cl_ord_id; # optional client order ID
    string native_ord_id; # optional exchange native order ID
    
```

### AmendRequest
Some exchanges support amending an existing order.

One of the two (`cl_ord_id`, `native_ord_id`) fields must be provided.

At least one of (`new_qty`, `new_price`) must be provided.

```
    int64 req_id; # unique request ID generated by MonotonicallyIncreaseGenerator
    int64 timestamp; # local timestamp when the request was created (microseconds UTC)

    XMarketId market_id;
    int64 account_id;

    int64 cl_ord_id; # optional client order ID
    string native_ord_id; # optional exchange native order ID

    double new_price;
    double new_qty;
    
```

### OrderResponseStatus enum
```
        UNKNOWN = 0;

        OK = 5;

        FAILED_POST_ONLY = 10; # when order canceled due to post-only violation

        FAILED_RATELIMIT = 20; # rate limit exceeded

        FAILED_500 = 30; # exchange internal error

        FAILED_400 = 40; # bad request

        FAILED_ORDER_NOT_FOUND = 50; # no order found 

```

### OrderResponse 
Typically the REST response for a request.

```
    int64 req_id; # unique request ID that was sent; used for matching request/response

    int64 timestamp; # exchange timestamp (microseconds UTC)
    int64 rcv_timestamp; # local timestamp when the response was received (microseconds UTC)

    int64 cl_ord_id; # optional client order ID
    string native_ord_id; # optional exchange native order ID


    OrderResponseStatus status; # enum

    XExecution exec; # optional; if the response contains the resulting order, it should be converted to XExecution unified format

```